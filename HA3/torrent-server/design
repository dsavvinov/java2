1. New user (or update)
  ====== NET LAYER ============
  - User connects to server (Server class <-> Client class. ClientHandler created)
  - Client sends request, ClientHandler accepts and parses request. Everything is according to protocol.
  * Request should be Update for new user. CommandFactory is responsible for parsing particular
    Command and proper arguments for that Command (i.e. responsible for constructing correct
    instance of some Command-subclass).
  ====== BORDER BETWEEN NET AND LOGIC LAYER ========
  - Command is created using CommandFactory - here
  - Command is called.
    ====== LOGIC LAYER (DOESN'T KNOW ANYTHING ABOUT NET OR WHATEVER) =======
    - Command updates list of active users via 'updateActive(user)' call to UsersDB
    - Command updates list of files seeded by this user via `updateSeededFiles()` call to UsersDB
    - Command invalidates all old files, seeded by that user (new list is given)
    - For each file in update, update list of users that seed this file
    * Think about last two steps. They can be done as one (to reduce calls to
    potentially expensive DB's interfaces) or even automatically (dependent tables in DBMS?)
    - Return gracefully
    ==========================================================================
  - Send OK response to client
  - Close connection gracefully

2. Upload
  - Net interaction is the same as above
  - Command updates FilesDB via call `uploadFile(file, user)`
  - Command updates list of files that user seeds via call `uploadFile(file, user)`








Issues:
  1. Modification in files. System should know if particular user modified some file between `update()`-calls
  2. Files and blocks. Approaches:
    - everything work with block, not file. Block points to owner-file
    - everything work with files, file contain list of blocks. Shit.
  3. Exception-safety and data consistency. What if during `update()`-call something fails, and we are left with
    partially-finished update? DB's should have transaction-like interface!
    3*. Probably it is overcomplicating things, but note that as we have two simultaneous transactions in parallel
    (one to FilesDB, another to UsersDB), commits are not atomic, i.e. first can succeed and second can fail, resulting
    in inconsistent state again. TODO: can commits fail?
  4. Protocol.
    a. How send requests to make parsing command and its arguments easier for Factory? TODO: Consider sending enum first for
    dispatching
    b. How separate messages in wire? Consider sending message size via Protobuf (mess with .proto-files is not fun though)
    c. Importantly, how denote end of message, i.e. when server should end receiving message and start parsing it?
  5. DB's. FilesDB and UsersDB look very coupled. Moreover, it's not really two separate DB's (strictly speaking, logic layer
    doesn't really care). And keeping them in sync look tiresome and redundant for commands (commands then should know about how
    the data is stored - not physically, but logically at least)
    TODO: Consider leaving only one `Database` interface instead.
  6. KeepAlive mechanism. Probably, DB should store some `lastSeen` info about user and lazily delete dead users on request that
    touches them somehow.
    Another approach is too use separate thread for each client, and that thread won't die after end of session but rather will sleep
    for 5 minutes. If client comes again, this thread is interrupted and forced to service the client again. Otherwise, he wakes up
    after 5 minutes and does all the job to invalidate that user. This is better because generally DB shouldn't know about users,
    timeouts, invalidating and the stuff (well, it can, but it looks much prettier as a just stupid storage).
    TODO: think about spurious wake-ups and proper messaging between threads. And how create that threads (they should be lightweight).
          And persistence is a total pain in the ass.
          Lol maybe Akka? :D :D
